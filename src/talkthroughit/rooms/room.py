import uuid
from pathlib import Path

import streamlit as st

from talkthroughit.llm.chat import create_ask_question_chain
from talkthroughit.llm.retrieval import create_vector_store


# Define the base directory for session data
@st.cache_data
def get_sessions_dir() -> Path:
    return Path(st.secrets['paths']['rooms_dir'])


class Room:
    def __init__(self, id: str) -> None:
        self.id = id

        # Initialize data directory if missing
        self.path = get_sessions_dir() / id
        self.path.mkdir(parents=True, exist_ok=True)

        # Initialize session attributes
        self.topic: str = "<unset>"
        self.documents: list[str] = []
        self.message_history: list = []

    def initialize(self, topic: str,
                   documents: list[tuple[str, bytes]]) -> None:
        """
        Initializes the session with a topic string and uploaded documents.
        """
        # Set the topic and document filenames on the session object
        self.topic = topic
        self.documents = [filename for filename, _ in documents]

        # Write documents to the session directory
        docs_path = self.path / 'documents'
        docs_path.mkdir(parents=True, exist_ok=True)
        for filename, data in documents:
            with open(docs_path / filename, 'wb') as f:
                f.write(data)

        # Create a vector store from the documents
        self.vector_store = create_vector_store(docs_path)
        self.retriever = self.vector_store.as_retriever()

        # Set up question-asking chains
        self.ask_question_chain = create_ask_question_chain(self.retriever)
        self.ask_question_chain_with_whiteboard = create_ask_question_chain(
            self.retriever,
            image_arguments=['whiteboard_image'])
        self.ask_question_chain_with_code = create_ask_question_chain(
            self.retriever,
            text_arguments=['code_snippet'])

    def get_question(self, user_message: str,
                     code_snippet: str | None = None,
                     whiteboard_image_b64: str | None = None) -> str:
        """
        Invokes the question-asking with the user's latest explanation,
        including either code or whiteboard input. Updates the message history
        with this user message and a new bot question (but NOT a provided code
        snippet or whiteboard image).

        Returns a new question generated by the model.
        """
        if code_snippet is not None and whiteboard_image_b64 is not None:
            raise ValueError(
                "Only one of code_snippet or whiteboard_image_b64 "
                "should be provided.")

        # Select the appropriate chain and prepare inputs
        chain = self.ask_question_chain
        inputs = {
            'topic': self.topic,
            'input': user_message,
            'chat_history': self.message_history
        }
        if code_snippet is not None:
            chain = self.ask_question_chain_with_code
            inputs['code_snippet'] = code_snippet
        elif whiteboard_image_b64 is not None:
            chain = self.ask_question_chain_with_whiteboard
            inputs['whiteboard_image'] = whiteboard_image_b64

        # Invoke the chain to get a question
        question = chain.invoke(inputs)

        # Add the user's message and the bot's question to the history
        self.message_history.append(('user', user_message))
        self.message_history.append(('bot', question))

        return question


@st.cache_resource(ttl='1d')
def get_room(id: str):
    """
    Retrieves (or creates, if missing) a Room object by its identifier.
    The attached room data expires after one day.
    """
    return Room(id)


def create_room(topic: str, documents: list[tuple[str, bytes]]) -> str:
    """
    Creates a new session with the given topic and documents.
    Returns the identifier for the newly created session.
    """
    # Generate a unique session ID
    session_id = uuid.uuid4().hex

    # Initialize the session
    session = get_room(session_id)
    session.initialize(topic, documents)

    return session_id
